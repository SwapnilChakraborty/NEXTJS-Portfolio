import { instrumentFetchRequest } from '@sentry-internal/tracing';
import { defineIntegration, convertIntegrationFnToClass, getClient, isSentryRequestUrl, addBreadcrumb } from '@sentry/core';
import { LRUMap, addFetchInstrumentationHandler, stringMatchesSomePattern } from '@sentry/utils';

const INTEGRATION_NAME = 'WinterCGFetch';

const HAS_CLIENT_MAP = new WeakMap();

const _winterCGFetch = ((options = {}) => {
  const breadcrumbs = options.breadcrumbs === undefined ? true : options.breadcrumbs;
  const shouldCreateSpanForRequest = options.shouldCreateSpanForRequest;

  const _createSpanUrlMap = new LRUMap(100);
  const _headersUrlMap = new LRUMap(100);

  const spans = {};

  /** Decides whether to attach trace data to the outgoing fetch request */
  function _shouldAttachTraceData(url) {
    const client = getClient();

    if (!client) {
      return false;
    }

    const clientOptions = client.getOptions();

    if (clientOptions.tracePropagationTargets === undefined) {
      return true;
    }

    const cachedDecision = _headersUrlMap.get(url);
    if (cachedDecision !== undefined) {
      return cachedDecision;
    }

    const decision = stringMatchesSomePattern(url, clientOptions.tracePropagationTargets);
    _headersUrlMap.set(url, decision);
    return decision;
  }

  /** Helper that wraps shouldCreateSpanForRequest option */
  function _shouldCreateSpan(url) {
    if (shouldCreateSpanForRequest === undefined) {
      return true;
    }

    const cachedDecision = _createSpanUrlMap.get(url);
    if (cachedDecision !== undefined) {
      return cachedDecision;
    }

    const decision = shouldCreateSpanForRequest(url);
    _createSpanUrlMap.set(url, decision);
    return decision;
  }

  return {
    name: INTEGRATION_NAME,
    // TODO v8: Remove this again
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    setupOnce() {
      addFetchInstrumentationHandler(handlerData => {
        const client = getClient();
        if (!client || !HAS_CLIENT_MAP.get(client)) {
          return;
        }

        if (isSentryRequestUrl(handlerData.fetchData.url, client)) {
          return;
        }

        instrumentFetchRequest(
          handlerData,
          _shouldCreateSpan,
          _shouldAttachTraceData,
          spans,
          'auto.http.wintercg_fetch',
        );

        if (breadcrumbs) {
          createBreadcrumb(handlerData);
        }
      });
    },
    setup(client) {
      HAS_CLIENT_MAP.set(client, true);
    },
  };
}) ;

const winterCGFetchIntegration = defineIntegration(_winterCGFetch);

/**
 * Creates spans and attaches tracing headers to fetch requests on WinterCG runtimes.
 *
 * @deprecated Use `winterCGFetchIntegration()` instead.
 */
// eslint-disable-next-line deprecation/deprecation
const WinterCGFetch = convertIntegrationFnToClass(
  INTEGRATION_NAME,
  winterCGFetchIntegration,
)

;

// eslint-disable-next-line deprecation/deprecation

function createBreadcrumb(handlerData) {
  const { startTimestamp, endTimestamp } = handlerData;

  // We only capture complete fetch requests
  if (!endTimestamp) {
    return;
  }

  if (handlerData.error) {
    const data = handlerData.fetchData;
    const hint = {
      data: handlerData.error,
      input: handlerData.args,
      startTimestamp,
      endTimestamp,
    };

    addBreadcrumb(
      {
        category: 'fetch',
        data,
        level: 'error',
        type: 'http',
      },
      hint,
    );
  } else {
    const data = {
      ...handlerData.fetchData,
      status_code: handlerData.response && handlerData.response.status,
    };
    const hint = {
      input: handlerData.args,
      response: handlerData.response,
      startTimestamp,
      endTimestamp,
    };
    addBreadcrumb(
      {
        category: 'fetch',
        data,
        type: 'http',
      },
      hint,
    );
  }
}

export { WinterCGFetch, winterCGFetchIntegration };
//# sourceMappingURL=wintercg-fetch.js.map
