import type { Transaction, WebFetchHeaders, WrappedFunction } from '@sentry/types';
import type { NextApiRequest, NextApiResponse } from 'next';
import type { RequestAsyncStorage } from '../config/templates/requestAsyncStorageShim';
export type ServerComponentContext = {
    componentRoute: string;
    componentType: string;
    /**
     * @deprecated pass a complete `Headers` object with the `headers` field instead.
     */
    sentryTraceHeader?: string;
    /**
     * @deprecated pass a complete `Headers` object with the `headers` field instead.
     */
    baggageHeader?: string;
    headers?: WebFetchHeaders;
};
export type GenerationFunctionContext = {
    requestAsyncStorage?: RequestAsyncStorage;
    componentRoute: string;
    componentType: string;
    generationFunctionIdentifier: string;
};
export interface RouteHandlerContext {
    method: 'GET' | 'POST' | 'PUT' | 'PATCH' | 'DELETE' | 'HEAD' | 'OPTIONS';
    parameterizedRoute: string;
    /**
     * @deprecated pass a complete `Headers` object with the `headers` field instead.
     */
    sentryTraceHeader?: string;
    /**
     * @deprecated pass a complete `Headers` object with the `headers` field instead.
     */
    baggageHeader?: string;
    headers?: WebFetchHeaders;
}
export type VercelCronsConfig = {
    path?: string;
    schedule?: string;
}[] | undefined;
export type NextApiHandler = {
    (req: NextApiRequest, res: NextApiResponse): void | Promise<void> | unknown | Promise<unknown>;
    __sentry_route__?: string;
    /**
     * A property we set in our integration tests to simulate running an API route on platforms that don't support streaming.
     */
    __sentry_test_doesnt_support_streaming__?: true;
};
export type WrappedNextApiHandler = {
    (req: NextApiRequest, res: NextApiResponse): Promise<void> | Promise<unknown>;
    __sentry_route__?: string;
    __sentry_wrapped__?: boolean;
};
export type AugmentedNextApiRequest = NextApiRequest & {
    __withSentry_applied__?: boolean;
};
export type AugmentedNextApiResponse = NextApiResponse & {
    __sentryTransaction?: Transaction;
};
export type ResponseEndMethod = AugmentedNextApiResponse['end'];
export type WrappedResponseEndMethod = AugmentedNextApiResponse['end'] & WrappedFunction;
//# sourceMappingURL=types.d.ts.map