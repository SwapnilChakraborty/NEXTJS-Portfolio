var {
  _nullishCoalesce,
  _optionalChain
} = require('@sentry/utils');

Object.defineProperty(exports, '__esModule', { value: true });

const core = require('@sentry/core');
const utils = require('@sentry/utils');
const debugBuild = require('./debug-build.js');
const nextNavigationErrorUtils = require('./nextNavigationErrorUtils.js');
const platformSupportsStreaming = require('./utils/platformSupportsStreaming.js');
const responseEnd = require('./utils/responseEnd.js');

/**
 * Wraps a Next.js Server Action implementation with Sentry Error and Performance instrumentation.
 */
function withServerActionInstrumentation(
  ...args
) {
  if (typeof args[1] === 'function') {
    const [serverActionName, callback] = args;
    return withServerActionInstrumentationImplementation(serverActionName, {}, callback);
  } else {
    const [serverActionName, options, callback] = args;
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    return withServerActionInstrumentationImplementation(serverActionName, options, callback);
  }
}

// eslint-disable-next-line @typescript-eslint/no-explicit-any
async function withServerActionInstrumentationImplementation(
  serverActionName,
  options,
  callback,
) {
  core.addTracingExtensions();
  return core.withIsolationScope(isolationScope => {
    const sendDefaultPii = _optionalChain([core.getClient, 'call', _ => _(), 'optionalAccess', _2 => _2.getOptions, 'call', _3 => _3(), 'access', _4 => _4.sendDefaultPii]);

    let sentryTraceHeader;
    let baggageHeader;
    const fullHeadersObject = {};
    try {
      sentryTraceHeader = _nullishCoalesce(_optionalChain([options, 'access', _5 => _5.headers, 'optionalAccess', _6 => _6.get, 'call', _7 => _7('sentry-trace')]), () => ( undefined));
      baggageHeader = _optionalChain([options, 'access', _8 => _8.headers, 'optionalAccess', _9 => _9.get, 'call', _10 => _10('baggage')]);
      _optionalChain([options, 'access', _11 => _11.headers, 'optionalAccess', _12 => _12.forEach, 'call', _13 => _13((value, key) => {
        fullHeadersObject[key] = value;
      })]);
    } catch (e) {
      debugBuild.DEBUG_BUILD &&
        utils.logger.warn(
          "Sentry wasn't able to extract the tracing headers for a server action. Will not trace this request.",
        );
    }

    isolationScope.setSDKProcessingMetadata({
      request: {
        headers: fullHeadersObject,
      },
    });

    return core.continueTrace(
      {
        sentryTrace: sentryTraceHeader,
        baggage: baggageHeader,
      },
      async () => {
        try {
          return await core.startSpan(
            {
              op: 'function.server_action',
              name: `serverAction/${serverActionName}`,
              metadata: {
                source: 'route',
              },
            },
            async span => {
              const result = await core.handleCallbackErrors(callback, error => {
                if (nextNavigationErrorUtils.isNotFoundNavigationError(error)) {
                  // We don't want to report "not-found"s
                  _optionalChain([span, 'optionalAccess', _14 => _14.setStatus, 'call', _15 => _15('not_found')]);
                } else if (nextNavigationErrorUtils.isRedirectNavigationError(error)) {
                  // Don't do anything for redirects
                } else {
                  _optionalChain([span, 'optionalAccess', _16 => _16.setStatus, 'call', _17 => _17('internal_error')]);
                  core.captureException(error, {
                    mechanism: {
                      handled: false,
                    },
                  });
                }
              });

              if (options.recordResponse !== undefined ? options.recordResponse : sendDefaultPii) {
                core.getIsolationScope().setExtra('server_action_result', result);
              }

              if (options.formData) {
                options.formData.forEach((value, key) => {
                  core.getIsolationScope().setExtra(
                    `server_action_form_data.${key}`,
                    typeof value === 'string' ? value : '[non-string value]',
                  );
                });
              }

              return result;
            },
          );
        } finally {
          if (!platformSupportsStreaming.platformSupportsStreaming()) {
            // Lambdas require manual flushing to prevent execution freeze before the event is sent
            await responseEnd.flushQueue();
          }

          if (process.env.NEXT_RUNTIME === 'edge') {
            // flushQueue should not throw
            // eslint-disable-next-line @typescript-eslint/no-floating-promises
            responseEnd.flushQueue();
          }
        }
      },
    );
  });
}

exports.withServerActionInstrumentation = withServerActionInstrumentation;
//# sourceMappingURL=withServerActionInstrumentation.js.map
