var {
  _nullishCoalesce,
  _optionalChain
} = require('@sentry/utils');

Object.defineProperty(exports, '__esModule', { value: true });

const core = require('@sentry/core');
const utils = require('@sentry/utils');
const nextNavigationErrorUtils = require('./nextNavigationErrorUtils.js');
const commonObjectTracing = require('./utils/commonObjectTracing.js');
const responseEnd = require('./utils/responseEnd.js');

/**
 * Wraps an `app` directory server component with Sentry error instrumentation.
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function wrapServerComponentWithSentry(
  appDirComponent,
  context,
) {
  core.addTracingExtensions();
  const { componentRoute, componentType } = context;

  // Even though users may define server components as async functions, for the client bundles
  // Next.js will turn them into synchronous functions and it will transform any `await`s into instances of the `use`
  // hook. ðŸ¤¯
  return new Proxy(appDirComponent, {
    apply: (originalFunction, thisArg, args) => {
      // TODO: If we ever allow withIsolationScope to take a scope, we should pass a scope here that is shared between all of the server components, similar to what `commonObjectToPropagationContext` does.
      return core.withIsolationScope(isolationScope => {
        const completeHeadersDict = context.headers
          ? utils.winterCGHeadersToDict(context.headers)
          : {};

        isolationScope.setSDKProcessingMetadata({
          request: {
            headers: completeHeadersDict,
          },
        });

        const incomingPropagationContext = utils.propagationContextFromHeaders(
          // eslint-disable-next-line deprecation/deprecation
          _nullishCoalesce(context.sentryTraceHeader, () => ( completeHeadersDict['sentry-trace'])),
          // eslint-disable-next-line deprecation/deprecation
          _nullishCoalesce(context.baggageHeader, () => ( completeHeadersDict['baggage'])),
        );

        const propagationContext = commonObjectTracing.commonObjectToPropagationContext(context.headers, incomingPropagationContext);
        isolationScope.setPropagationContext(propagationContext);
        core.getCurrentScope().setPropagationContext(propagationContext);

        return core.startSpanManual(
          {
            op: 'function.nextjs',
            name: `${componentType} Server Component (${componentRoute})`,
            attributes: {
              [core.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: 'component',
              [core.SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.function.nextjs',
            },
          },
          span => {
            return core.handleCallbackErrors(
              () => originalFunction.apply(thisArg, args),
              error => {
                if (nextNavigationErrorUtils.isNotFoundNavigationError(error)) {
                  // We don't want to report "not-found"s
                  _optionalChain([span, 'optionalAccess', _ => _.setStatus, 'call', _2 => _2('not_found')]);
                } else if (nextNavigationErrorUtils.isRedirectNavigationError(error)) {
                  // We don't want to report redirects
                  _optionalChain([span, 'optionalAccess', _3 => _3.setStatus, 'call', _4 => _4('ok')]);
                } else {
                  _optionalChain([span, 'optionalAccess', _5 => _5.setStatus, 'call', _6 => _6('internal_error')]);
                  core.captureException(error, {
                    mechanism: {
                      handled: false,
                    },
                  });
                }
              },
              () => {
                _optionalChain([span, 'optionalAccess', _7 => _7.end, 'call', _8 => _8()]);

                // flushQueue should not throw
                // eslint-disable-next-line @typescript-eslint/no-floating-promises
                responseEnd.flushQueue();
              },
            );
          },
        );
      });
    },
  });
}

exports.wrapServerComponentWithSentry = wrapServerComponentWithSentry;
//# sourceMappingURL=wrapServerComponentWithSentry.js.map
