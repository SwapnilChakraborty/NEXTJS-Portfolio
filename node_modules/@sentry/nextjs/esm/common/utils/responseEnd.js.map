{"version":3,"file":"responseEnd.js","sources":["../../../../src/common/utils/responseEnd.ts"],"sourcesContent":["import type { ServerResponse } from 'http';\nimport { flush, setHttpStatus } from '@sentry/core';\nimport type { Span } from '@sentry/types';\nimport { fill, logger } from '@sentry/utils';\n\nimport { DEBUG_BUILD } from '../debug-build';\nimport type { ResponseEndMethod, WrappedResponseEndMethod } from '../types';\n\n/**\n * Wrap `res.end()` so that it ends the span and flushes events before letting the request finish.\n *\n * Note: This wraps a sync method with an async method. While in general that's not a great idea in terms of keeping\n * things in the right order, in this case it's safe, because the native `.end()` actually *is* (effectively) async, and\n * its run actually *is* (literally) awaited, just manually so (which reflects the fact that the core of the\n * request/response code in Node by far predates the introduction of `async`/`await`). When `.end()` is done, it emits\n * the `prefinish` event, and only once that fires does request processing continue. See\n * https://github.com/nodejs/node/commit/7c9b607048f13741173d397795bac37707405ba7.\n *\n * Also note: `res.end()` isn't called until *after* all response data and headers have been sent, so blocking inside of\n * `end` doesn't delay data getting to the end user. See\n * https://nodejs.org/api/http.html#responseenddata-encoding-callback.\n *\n * @param span The span tracking the request\n * @param res: The request's corresponding response\n */\nexport function autoEndSpanOnResponseEnd(span: Span, res: ServerResponse): void {\n  const wrapEndMethod = (origEnd: ResponseEndMethod): WrappedResponseEndMethod => {\n    return function sentryWrappedEnd(this: ServerResponse, ...args: unknown[]) {\n      finishSpan(span, this);\n      return origEnd.call(this, ...args);\n    };\n  };\n\n  // Prevent double-wrapping\n  // res.end may be undefined during build when using `next export` to statically export a Next.js app\n  if (res.end && !(res.end as WrappedResponseEndMethod).__sentry_original__) {\n    fill(res, 'end', wrapEndMethod);\n  }\n}\n\n/** Finish the given response's span and set HTTP status data */\nexport function finishSpan(span: Span | undefined, res: ServerResponse): void {\n  if (span) {\n    setHttpStatus(span, res.statusCode);\n    span.end();\n  }\n}\n\n/** Flush the event queue to ensure that events get sent to Sentry before the response is finished and the lambda ends */\nexport async function flushQueue(): Promise<void> {\n  try {\n    DEBUG_BUILD && logger.log('Flushing events...');\n    await flush(2000);\n    DEBUG_BUILD && logger.log('Done flushing events');\n  } catch (e) {\n    DEBUG_BUILD && logger.log('Error while flushing events:\\n', e);\n  }\n}\n"],"names":[],"mappings":";;;;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAAS,wBAAwB,CAAC,IAAI,EAAQ,GAAG,EAAwB;AAChF,EAAE,MAAM,aAAA,GAAgB,CAAC,OAAO,KAAkD;AAClF,IAAI,OAAO,SAAS,gBAAgB,EAAuB,GAAG,IAAI,EAAa;AAC/E,MAAM,UAAU,CAAC,IAAI,EAAE,IAAI,CAAC,CAAA;AAC5B,MAAM,OAAO,OAAO,CAAC,IAAI,CAAC,IAAI,EAAE,GAAG,IAAI,CAAC,CAAA;AACxC,KAAK,CAAA;AACL,GAAG,CAAA;AACH;AACA;AACA;AACA,EAAE,IAAI,GAAG,CAAC,OAAO,CAAC,CAAC,GAAG,CAAC,GAAA,GAAiC,mBAAmB,EAAE;AAC7E,IAAI,IAAI,CAAC,GAAG,EAAE,KAAK,EAAE,aAAa,CAAC,CAAA;AACnC,GAAE;AACF,CAAA;AACA;AACA;AACO,SAAS,UAAU,CAAC,IAAI,EAAoB,GAAG,EAAwB;AAC9E,EAAE,IAAI,IAAI,EAAE;AACZ,IAAI,aAAa,CAAC,IAAI,EAAE,GAAG,CAAC,UAAU,CAAC,CAAA;AACvC,IAAI,IAAI,CAAC,GAAG,EAAE,CAAA;AACd,GAAE;AACF,CAAA;AACA;AACA;AACO,eAAe,UAAU,GAAkB;AAClD,EAAE,IAAI;AACN,IAAI,eAAe,MAAM,CAAC,GAAG,CAAC,oBAAoB,CAAC,CAAA;AACnD,IAAI,MAAM,KAAK,CAAC,IAAI,CAAC,CAAA;AACrB,IAAI,eAAe,MAAM,CAAC,GAAG,CAAC,sBAAsB,CAAC,CAAA;AACrD,GAAI,CAAA,OAAO,CAAC,EAAE;AACd,IAAI,WAAA,IAAe,MAAM,CAAC,GAAG,CAAC,gCAAgC,EAAE,CAAC,CAAC,CAAA;AAClE,GAAE;AACF;;;;"}