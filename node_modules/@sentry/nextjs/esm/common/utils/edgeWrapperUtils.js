import { addTracingExtensions, continueTrace, startSpan, SEMANTIC_ATTRIBUTE_SENTRY_SOURCE, SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN, handleCallbackErrors, captureException, setHttpStatus } from '@sentry/core';
import { winterCGRequestToRequestData } from '@sentry/utils';
import { flushQueue } from './responseEnd.js';

/**
 * Wraps a function on the edge runtime with error and performance monitoring.
 */
function withEdgeWrapping(
  handler,
  options,
) {
  return async function ( ...args) {
    addTracingExtensions();
    const req = args[0];

    let sentryTrace;
    let baggage;

    if (req instanceof Request) {
      sentryTrace = req.headers.get('sentry-trace') || '';
      baggage = req.headers.get('baggage');
    }

    return continueTrace(
      {
        sentryTrace,
        baggage,
      },
      () => {
        return startSpan(
          {
            name: options.spanDescription,
            op: options.spanOp,
            attributes: {
              [SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: 'route',
              [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.function.nextjs.withEdgeWrapping',
            },
            metadata: {
              request: req instanceof Request ? winterCGRequestToRequestData(req) : undefined,
            },
          },
          async span => {
            const handlerResult = await handleCallbackErrors(
              () => handler.apply(this, args),
              error => {
                captureException(error, {
                  mechanism: {
                    type: 'instrument',
                    handled: false,
                    data: {
                      function: options.mechanismFunctionName,
                    },
                  },
                });
              },
            );

            if (span) {
              if (handlerResult instanceof Response) {
                setHttpStatus(span, handlerResult.status);
              } else {
                span.setStatus('ok');
              }
            }

            return handlerResult;
          },
        ).finally(() => flushQueue());
      },
    );
  };
}

export { withEdgeWrapping };
//# sourceMappingURL=edgeWrapperUtils.js.map
